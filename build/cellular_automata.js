// Generated by CoffeeScript 1.10.0
(function() {
  var automaton_for, clear_grid, load_automaton_for, load_color_rule, load_color_rules, set_up_controls_for,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Automaton = (function() {
    function Automaton(grid1, rule1, step_time) {
      this.grid = grid1;
      this.rule = rule1;
      this.step_time = step_time;
      this.step = bind(this.step, this);
      this.height = this.grid.height;
      this.width = this.grid.width;
    }

    Automaton.prototype.step = function() {
      return _.each(this._step_instructions(), (function(_this) {
        return function(row, row_number) {
          return _.each(row, function(value, cell_number) {
            return _this.grid.set({
              x: cell_number,
              y: row_number
            }, Number(value));
          });
        };
      })(this));
    };

    Automaton.prototype.start = function() {
      return this.interval_id = setInterval(this.step, this.step_time);
    };

    Automaton.prototype.stop = function() {
      return clearInterval(this.interval_id);
    };

    Automaton.prototype.clear = function() {
      return this._map_cells((function(_this) {
        return function(row_number, cell_number) {
          return _this.grid.turn_off({
            x: cell_number,
            y: row_number
          });
        };
      })(this));
    };

    Automaton.prototype._step_instructions = function() {
      return this._map_cells((function(_this) {
        return function(row_number, cell_number) {
          return _this.rule(cell_number, row_number, _this.grid);
        };
      })(this));
    };

    Automaton.prototype._map_cells = function(iteratee) {
      var i, ref, results;
      return _.map((function() {
        results = [];
        for (var i = 0, ref = this.height; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this), (function(_this) {
        return function(row_number) {
          var j, ref1, results1;
          return _.map((function() {
            results1 = [];
            for (var j = 0, ref1 = _this.width; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--){ results1.push(j); }
            return results1;
          }).apply(this), function(cell_number) {
            return iteratee(row_number, cell_number);
          });
        };
      })(this));
    };

    return Automaton;

  })();

  this.Grid = (function() {
    function Grid(container, arg) {
      var interactive;
      this.container = container;
      this.height = arg.height, this.width = arg.width, interactive = arg.interactive, this.states = arg.states;
      this.states || (this.states = 2);
      this._add_grid_to_container();
      if (interactive) {
        this._add_interactivity();
      }
    }

    Grid.prototype.turn_on = function(coordinates) {
      return this.set(coordinates, 1);
    };

    Grid.prototype.turn_off = function(coordinates) {
      return this.set(coordinates, 0);
    };

    Grid.prototype.toggle = function(coordinates) {
      return this.set(coordinates, (this.state(coordinates) + 1) % this.states);
    };

    Grid.prototype.state = function(coordinates) {
      return Number(this._grid_cell(coordinates).attr('data-state'));
    };

    Grid.prototype.is_on = function(coordinates) {
      return this.state(coordinates) > 0;
    };

    Grid.prototype.set = function(coordinates, value) {
      return this._grid_cell(coordinates).attr('data-state', value);
    };

    Grid.prototype._add_interactivity = function() {
      var self;
      self = this;
      return this.grid.find('td').click(function() {
        return self.toggle(jQuery(this).data('coordinates'));
      });
    };

    Grid.prototype._grid_cell = function(arg) {
      var x, y;
      x = arg.x, y = arg.y;
      return this.grid.find(".row" + y + "#cell" + x);
    };

    Grid.prototype._add_grid_to_container = function() {
      return this.container.append(this._grid());
    };

    Grid.prototype._grid = function() {
      this.grid = jQuery('<table/>');
      _.times(this.height, (function(_this) {
        return function(row_number) {
          return _this.grid.append(_this._row(row_number));
        };
      })(this));
      return this.grid;
    };

    Grid.prototype._row = function(row_number) {
      var row;
      row = jQuery('<tr/>');
      return _.times(this.width, (function(_this) {
        return function(cell_number) {
          return row.append(_this._cell(row_number, cell_number));
        };
      })(this));
    };

    Grid.prototype._cell = function(row_number, cell_number) {
      var cell;
      cell = jQuery('<td/>', {
        "class": "row" + row_number,
        id: "cell" + cell_number,
        'data-state': 0
      });
      return cell.data('coordinates', {
        x: cell_number,
        y: row_number
      });
    };

    return Grid;

  })();

  this.load_rule = function(rule) {
    clear_grid();
    load_color_rules(rule.colors);
    return load_automaton_for(rule);
  };

  load_color_rules = function(color_rules) {
    jQuery('style').remove();
    return _.each(color_rules, function(color, state) {
      return load_color_rule(state, color);
    });
  };

  clear_grid = function() {
    return jQuery('#grid_container').empty();
  };

  load_automaton_for = function(rule) {
    var automaton;
    automaton = automaton_for(rule);
    return set_up_controls_for(automaton);
  };

  automaton_for = function(rule) {
    var automaton, grid;
    grid = new Grid(jQuery('#grid_container'), {
      height: 30,
      width: 50,
      interactive: true,
      states: rule.states
    });
    return automaton = new Automaton(grid, rule.rule, 100);
  };

  set_up_controls_for = function(automaton) {
    jQuery('#start').off();
    jQuery('#stop').off();
    jQuery('#step').off();
    jQuery('#clear').off();
    jQuery('#start').click(function() {
      return automaton.start();
    });
    jQuery('#stop').click(function() {
      return automaton.stop();
    });
    jQuery('#step').click(function() {
      return automaton.step();
    });
    return jQuery('#clear').click(function() {
      return automaton.clear();
    });
  };

  load_color_rule = function(state, color) {
    return jQuery("<style>[data-state='" + state + "'] { background-color: " + color + "; }</style>").appendTo('head');
  };

  this.display_menu = function() {
    var menu;
    menu = jQuery('<select/>', {
      id: 'menu'
    });
    _.each(_.keys(this.rules), function(rule_name) {
      return menu.append(jQuery('<option/>', {
        value: rule_name,
        text: this.rules[rule_name].name
      }));
    });
    menu.change((function(_this) {
      return function() {
        return _this.load_rule(_this.rules[menu.val()]);
      };
    })(this));
    return jQuery('#controls').append(menu);
  };

  $((function(_this) {
    return function() {
      _this.display_menu();
      return _this.load_rule(_this.rules.conways_game_of_life);
    };
  })(this));

  this.rules = {
    conways_game_of_life: {
      name: "Conway's Game of Life",
      states: 2,
      colors: ['inherit', '#E8107C'],
      rule: function(x, y, grid) {
        var east, north, northeast, northwest, number_of_live_neighbors, self, south, southeast, southwest, west;
        self = grid.is_on({
          x: x,
          y: y
        });
        northwest = grid.is_on({
          x: x - 1,
          y: y - 1
        });
        north = grid.is_on({
          x: x,
          y: y - 1
        });
        northeast = grid.is_on({
          x: x + 1,
          y: y - 1
        });
        west = grid.is_on({
          x: x - 1,
          y: y
        });
        east = grid.is_on({
          x: x + 1,
          y: y
        });
        southwest = grid.is_on({
          x: x - 1,
          y: y + 1
        });
        south = grid.is_on({
          x: x,
          y: y + 1
        });
        southeast = grid.is_on({
          x: x + 1,
          y: y + 1
        });
        number_of_live_neighbors = _.compact([northwest, north, northeast, west, east, southwest, south, southeast]).length;
        switch (false) {
          case number_of_live_neighbors !== 3:
            return true;
          case !(number_of_live_neighbors < 2):
            return false;
          case !(number_of_live_neighbors > 3):
            return false;
          default:
            return self;
        }
      }
    },
    fire_propagation: {
      name: 'Fire Propagation',
      states: 7,
      colors: ['inherit', 'black', '#ED6509', '#ED6509', '#ED6509', '#ED6509', '#632E0A'],
      rule: function(x, y, grid) {
        var BURNED_OUT, FIREBREAK, FIRESTART, NORMAL, chance_of_catching_fire, east, neighbors, north, northeast, northwest, number_of_burning_neighbors, self, south, southeast, southwest, west;
        NORMAL = 0;
        FIREBREAK = 1;
        FIRESTART = 2;
        BURNED_OUT = 6;
        self = grid.state({
          x: x,
          y: y
        });
        if (self === FIREBREAK) {
          return FIREBREAK;
        }
        if (self > FIREBREAK) {
          return Math.min(self + 1, BURNED_OUT);
        }
        northwest = grid.state({
          x: x - 1,
          y: y - 1
        });
        north = grid.state({
          x: x,
          y: y - 1
        });
        northeast = grid.state({
          x: x + 1,
          y: y - 1
        });
        west = grid.state({
          x: x - 1,
          y: y
        });
        east = grid.state({
          x: x + 1,
          y: y
        });
        southwest = grid.state({
          x: x - 1,
          y: y + 1
        });
        south = grid.state({
          x: x,
          y: y + 1
        });
        southeast = grid.state({
          x: x + 1,
          y: y + 1
        });
        neighbors = [northwest, north, northeast, west, east, southwest, south, southeast];
        number_of_burning_neighbors = _.size(_.filter(neighbors, function(neighbor) {
          return neighbor > FIREBREAK && neighbor < BURNED_OUT;
        }));
        chance_of_catching_fire = number_of_burning_neighbors * 1 / 8;
        if (Math.random() < chance_of_catching_fire) {
          return FIRESTART;
        }
        return self;
      }
    },
    wire_world: {
      name: 'Wire World',
      states: 4,
      colors: ['inherit', 'black', 'yellow', 'orange'],
      rule: function(x, y, grid) {
        var BACKGROUND, HEAD, TAIL, WIRE, east, neighbors, north, northeast, northwest, number_of_active_neighbors, self, south, southeast, southwest, west;
        BACKGROUND = 0;
        WIRE = 1;
        HEAD = 2;
        TAIL = 3;
        self = grid.state({
          x: x,
          y: y
        });
        if (self === BACKGROUND) {
          return BACKGROUND;
        }
        if (self === HEAD) {
          return TAIL;
        }
        if (self === TAIL) {
          return WIRE;
        }
        northwest = grid.state({
          x: x - 1,
          y: y - 1
        });
        north = grid.state({
          x: x,
          y: y - 1
        });
        northeast = grid.state({
          x: x + 1,
          y: y - 1
        });
        west = grid.state({
          x: x - 1,
          y: y
        });
        east = grid.state({
          x: x + 1,
          y: y
        });
        southwest = grid.state({
          x: x - 1,
          y: y + 1
        });
        south = grid.state({
          x: x,
          y: y + 1
        });
        southeast = grid.state({
          x: x + 1,
          y: y + 1
        });
        neighbors = [northwest, north, northeast, west, east, southwest, south, southeast];
        number_of_active_neighbors = _.size(_.filter(neighbors, function(neighbor) {
          return neighbor === HEAD;
        }));
        if (number_of_active_neighbors === 1 || number_of_active_neighbors === 2) {
          return HEAD;
        }
        return WIRE;
      }
    },
    rule_110: {
      name: 'Rule 110',
      states: 2,
      colors: ['inherit', '#E8107C'],
      rule: function(x, y, grid) {
        var north, northeast, northwest, outcomes, self, value;
        self = grid.state({
          x: x,
          y: y
        });
        if (self) {
          return 1;
        }
        northwest = grid.state({
          x: x - 1,
          y: y - 1
        });
        north = grid.state({
          x: x,
          y: y - 1
        });
        northeast = grid.state({
          x: x + 1,
          y: y - 1
        });
        outcomes = [0, 1, 1, 1, 0, 1, 1, 0];
        value = parseInt([northwest, north, northeast].join(''), 2);
        return outcomes[value] || 0;
      }
    }
  };

}).call(this);
